(fn (mat-r mat-a mat-b)
  ; Перемножаем блоки матриц и отправляем их на обработку в соответствующие
  ; очереди. Можно заранее написать matrix-mul с подходящей сигнатурой

  (for (i (range l)
        j (range n)
        k (range m))
    (run matrix-mul (! zip 'i.j) (pin mat-a 'i.k) (pin mat-b 'k.j)))

  ; Процедура рекурсивного суммирования блоков данных из очереди

  (fn queue-sum (result sum block-queue n-blocks)
    (if (= 0 n-blocks)
      ; Все блоки учтены, возвращаем результат. Но чтобы получить результат надо
      ; дождаться связывания sum, которая может быть просто ссылкой. 

      (run (fn (r s) (:= r s)) (! pin result) (pin sum))

      ; В противном случае нужно вычислить следующие сумму и счётчик. И
      ; рекурсивно продолжить вычисление

      (do
        ; Мы можем в правиле указать параметры функции, система знает их
        ; системные имена и может на их основе сформировать позиции (контакты
        ; или очереди) для подстановки в правило

        (run matrix-add (! pin :sum) (pin sum) (zip block-queue))
          
        ; Рекурсивно продолжаем. Пользуемся ссылками на чтение -- ?, чтобы не
        ; блокировать процесс вычисления на ожидании завершения подсчёта суммы:
        ; сам блок данных с текущей суммой нужен только в правиле выше, как и
        ; очередной блок из очереди.  Пользуемся возможностью подставить в run
        ; вычисленное значение (- n-blocks 1): система способна сформировать всю
        ; необходимую обвязку самостоятельно

        (run queue-sum (! pin result)
                       (? pin :sum) (? zip block-queue) (- n-blocks 1)))))
  
  ; Запускаем процессы суммирования. Используем pin, чтобы не блокировать
  ; процесс и корректно пропустить чтение из очереди; а также возможность
  ; подставлять значения выражений в run, вместо имён связок.

  (for (i (range l)
        j (range n))
    (run queue-sum (! pin mat-r 'i.j) (zero-matrix) (? zip 'i.j) m)))

; Тут можно интересный вопрос поставить: насколько сложно будет компилятору
; понять, что (1) не нужно каждый раз производить новую нулевую матрицу; и что
; (2) не требуется для такой матрицы каждый раз генерировать новую
; автоматическую связку. (1), конечно, это стандартная техника в компиляции; и
; есть ощущение, что (2) вполне решается тем же самым способом. Для каждого
; значения, передаваемой в группе правил в облако Райд, можно использовать одну
; и ту же обвязку.
